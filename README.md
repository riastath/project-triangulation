# PROJECT : Ανάπτυξη Λογισμικού για Αλγοριθμικά Προβλήματα

## Μέρος 1 της εργασίας
Μη Αμβλυγώνια Τριγωνοποίηση Επίπεδων Γράφων Ευθύγραμμων Τμημάτων (Planar Straight Line Graphs) με τη χρήση της βιβλιοθήκης CGAL

1. Περιγραφή του προγράμματος.
Το πρόγραμμα χρησιμοποιεί την κλάση PSLG για να εκτελέσει τις λειτουργίες της τριγωνοποίησης. Από τη CGAL χρησιμοποιούνται τα Constrained_Delaunay_triangulation_2 και Exact_predicates_inexact_constructions_kernel, για τη δημιουργία της κλάσης CDT και της χρήσης της για τα ορίσματα και τη βασική υλοποίηση. Συγκεκριμένα, μια συνοπτική περιγραφή είναι η εξής :
- Αρχείο pslg.cpp : 

Στον __constructor__ της κλάσης χρησιμοποιείται η λειτουργία της boost βιβλιοθήκης με τη δομή ptree για να διαβάσει την είσοδο από το δοσμένο .json αρχείο, και διατρέχοντας τους κόμβους (κάθε κατηγορία της εισόδου) προσθέτει τα στοιχεία σε αντίστοιχα vectors. Για τα edges / constraints, χρησιμοποιείται std::pair για τον τύπο των στοιχείων.

Η συνάρτηση __produce_output__, με αντίστοιχο τρόπο δημιουργεί το τελικό .json αρχείο εξόδου χρησιμοποιώντας το ptree. Επισημαίνεται πως για την εισαγωγή των edges χρειάστηκε να δημιουργηθούν δυο ακόμα ptrees για κάθε point χωριστά, ώστε να φτιαχτούν κόμβοι με τις θέσεις τους (υπολογισμένες με τη συνάρτηση distance) στο point vector της κλάσης και το κενό string, και μετά να προστεθούν στο τελικό ptree ως ζεύγη.

Η συνάρτηση __delaunay_passer__ εισάγει τα στοιχεία σε delaunay instance για χρήση στη main. 

Η συνάρτηση __angle(Point a, Point b, Point c)__ υπολογίζει με τη χρήση μαθηματικών τις μοίρες της γωνίας δοσμένων 3 σημείων, με τον τύπο του εσωτερικού γινομένου και του συνημιτόνου. Χρησιμοποιείται στις υπόλοιπες συναρτήσεις για να βρίσκει τις αμβλείες γωνίας στα τρίγωνα του σχήματος.

Οι __is_obtuse(Point a, Point b, Point c)__ και __is_obtuse_gen(CDT* instance)__ αποτελούν συναρτήσεις εντοπισμού της ύπαρξης αμβλείας γωνίας, στην περίπτωση που είναι γνωστά σημεία και στην περίπτωση που είναι γνωστό ένα αντικείμενο CDT, αντίστοιχα. Η δεύτερη χρησιμοποίει την ύπαρξη των _vertices_ και των _finite faces_ της CDT, για να διατρέξει τα τρίγωνα και λαμβάνοντας τα σημεία από τα handles που επιστρέφονται, να υπολογίσει τις γωνίες και να ελέγξει τις μοίρες τους.

Στη συνέχεια, υλοποιούνται 4 μέθοδοι εισαγωγής steiner points. Όλες ακολουθούν το πρότυπο ορισμάτων (CDT instance, CDT::Face_handle face, int num_obtuse), βρίσκουν το σημείο steiner για την εισαγωγή, το προσθέτουν στο instance που δίνεται και επιστρέφουν ζεύγος του σημείου αυτού με τη βελτίωση από την εισαγωγή του (υπολογισμένη με μια διαφορά ακεραίων).

Η __insert_steiner_center__ ελέγχει και τα γειτονικά face handles αυτού που δίνεται. Χρησιμοποιώντας το extra point, εκχωρείται τιμή του νέου σημείου στην περίπτωση εύρεσης αμβλείας γωνίας. Έτσι μπορεί να υπολογιστεί τελικά το centroid του τετραπλεύρου που δημιουργείται, το οποίο περιέχει το επιπλέον αυτό σημείο. Τα a, b, c είναι οι κορυφές του face που δίνεται. 

Η __insert_steiner_mid__ εισάγει στο μέσο της ευθείας το steiner point, αφού βρει πρώτα ποια είναι η ευθεία που χρειάζεται βρίσκοντας την αμβλεία γωνία.

Η __insert_steiner_bisection__ εισάγει το steiner point στη διχοτόμο της γωνίας. Αυτή η μέθοδος δεν λειτουργεί με τον αναμενόμενο τρόπο για όλα τα instances. Χρησιμοποιείται εύρεση της κορυφής της αμβλείας και ο μαθηματικός τύπος με τα μήκη που βρίσκονται, ώστε να υπολογιστούν οι συντεταγμένες του σημείου της διχοτόμου χωριστά.

Η __insert_steiner_projection__ εισάγει το steiner point στην προβολή, της οποίας βρίσκει την εξίσωση ευθείας και το σημείο τομής της με την πλευρά του τρίγωνου στην οποία θα πέσει η προβολή.

Οι συναρτήσεις __insert_steiner_point__ και __insert_all_steiner__ εκτελούν απλές εισαγωγές στο αντικείμενο.


Η __flip_edges__ επιχειρεί να κάνει flip σε κάθε τρίγωνο με αμβλεία γωνιά. Για να μπορέσει να κάνει flip, θα πρέπει το τρίγωνο καθώς και ο γείτονας του με το οποίο θα κάνει flip να μην έχουν αλλάξει από προηγούμενα flips. Για αυτούς τους ελέγχους, η συνάρτηση χρησιμοποιεί δυο vectors, στα οποία αποθηκεύει τα τρίγωνα που κάναν flip, μαζί με τις γωνίες που κάλεσαν το flip, και τους γείτονες με τους οποίους κάναν flip. Επίσης χρησιμοποιεί την συνάρτηση __face_is_infinite__ για να ελέγξει αν υπάρχει ο γείτονας. Για να μην χαλάει τα τρίγωνα πριν τελειώσει τους ελέγχους, κάνει τα flip μετά αφού έχει ελέγξει όλο τον γράφο, καλώντας την __cdt->flip__ για όλα τα τρίγωνα που αποθήκευσε στο πρώτο vector.


Στο αρχείο __ex.cpp__, βρίσκεται η main συνάρτηση του προγράμματος. Χρησιμοποιείται ενα loop και ενα faces iterator, ώστε διατρέχοντας όλα τα faces του σχήματος να ελέγχονται για το καθένα οι μέθοδοι τριγωνοποιήσης. Με τη χρήση ενός ακεραίου _result__ που συγκρίνεται με το _improvement_ για να βρεθεί κάθε φορά αν υπάρχει βελτίωση της διαδικασίας, επιτυγχάνεται το καλύτερο δυνατό αποτέλεσμα με τη χρήση των συναρτήσεων που έχουμε. Επειδή κάποια instances δε συγκλίνουν, χρησιμοποιείται επιπλέον μέγιστος αριθμός επαναλήψεων 20, για να σταματήσει η διαδικασία μετά από ένα σημείο σε αυτά. Τελικά, εισάγεται στο face το steiner point που επιλέχτηκε, και τελικά σε όλο το σχήμα όλα τα steiner points αν υπήρχε βελτίωση. Τελικά, τυπώνονται οι αμβλείες γωνίες που έχουν μείνει μετά τη διαδικασία, για σύγκριση με την αρχική κατάσταση.

2. Κατάλογος των αρχείων κώδικα και ο ρόλος τους
Τα αρχεία κώδικα είναι τα παρακάτω :
- build.sh : bash script με εντολές για τη δημιουργία του προγράμματος
- CMakeLists.txt : περιέχει τις απαραίτητες εντολές για τη μεταγλώττιση της εργασίας με το εργαλείο cmake
- ex.cpp : η main συνάρτηση του προγράμματος που ελέγχει για το δοσμένο σχήμα τις μεθόδους τριγωνοποίησης και προσπαθεί να μειώσει όσο περισσότερο γίνεται τις αμβλείες γωνίες.
- pslg.cpp : το αρχείο της κλάσης pslg, που χρησιμοποιήθηκε για την υλοποίηση των μεθόδων τριγωνοποίησης. Περιέχει τις λειτουργίες για το edge flipping, τις εισαγωγές steiner points και βοηθητικές συναρτήσεις όπως υπολογισμό γωνίας και έλεγχο για την υπάρξη αμβλείας γωνίας.
- pslg.h : το header file της παραπάνω κλάσης, με τις δηλώσεις όλων των μελών και των μεθόδων της, και τα απαραίτητα includes.
- output.json : Το αποτέλεσμα που δημιουργείται από τη συνάρτηση της κλάσης pslg, produce_output, με τα απαραίτητα στοιχεία όπως περιγράφονται στην εκφώνηση της εργασίας. 
- Makefile για τη μεταγλώττιση.
- Στο νέο κομμάτι : opt_algorithms.cpp, opt_algorithms.hpp

3. Οδηγίες μεταγλώττισης.
Για τη μεταγλώττιση της εργασίας αρκεί να εκτελέσουμε τις παρακάτω εντολές
- chmod +x build.sh (αν χρειάζεται, για την εκτέλεση του bash script)
- make 

4. Οδηγίες χρήσης του προγράμματος.
Η εντολή για το πρόγραμμα είναι :
./opt_triangulation –i /path/to/input.json –o /path/to/output.json
Τρέχοντας το πρόγραμμα και δίνοντας το επιθυμητό instance, βλέπουμε το αποτέλεσμα με τη γραφική αναπαράσταση της βιβλιοθήκης Qt, καθώς και τον αριθμό των αμβλείων πριν και μετά τη διαδικασία.
Με το flag -f, υπάρχει η δυνατότητα επιλογής για edge flips ή όχι.


5. Πλήρη στοιχεία των φοιτητών της ομάδας
Τα μέλη της ομάδας είναι :
- Γιώργος Πράππας, A.M : 1115202100163
- Μαρία Σταθοπούλου, Α.Μ : 1115202100177

Το github repository link (private) είναι https://github.com/riastath/project1


## Μέρος 2 της εργασίας 

Σημειώσεις για κάποιες αλλαγές για το δεύτερο κομμάτι της εργασίας :
- Δημιουργήθηκε στο αρχείο pslg.cpp μια νέα συνάρτηση, bool is_obtuse_face(CDT::Face_handle f), που απλώς ελέγχει αν είναι αμβλυγώνιο το τρίγωνο χρησιμοποιώντας face handle. Θα φανεί χρήσιμη στα optimization algorithms που ζητούνται.
- Προστέθηκε η 5η μέθοδος steiner point, εισαγωγή circumcenter, που δεν είχε υλοποιηθεί προηγουμένως.
- Χρησιμοποιήθηκε η δομή της CGAL, Triangle, για τη μέθοδο steiner point circumcenter, για πιο άμεσο έλεγχο.
- Προστέθηκαν κάποια απλά getter functions στο pslg.cpp.
- Προστέθηκε στο pslg.cpp η συνάρτηση return_cdt, που επιστρέφει το cdt κάνοντας εισαγωγή του σημείου που δίνεται στη συνάρτηση. Χρησιμοποιείται στους αλγορίθμους βελτιστοποίησης για να μην επηρεάζεται το cdt απευθείας και δημιουργηθούν προβλήματα.

Δημιουργήθηκε ένα νεο αρχείο, opt_algorithms.cpp και το αντίστοιχο header αρχείο, opt_algorithms.hpp. Στο πρώτο υλοποιούνται οι 3 αλγόριθμοι
βελτιστοποιήσης της τριγωνοποίησης. Συγκεκριμένα :

- __Local Search__ : Λειτουργεί με τη χρήση μεταβλητής "iterations" για να εκτελέσει όσες επαναλήψεις δωθούν από τον χρήστη. Σε κάθε επανάληψη ελέγχει κάθε μέθοδο εισαγωγής steiner points και με τη χρήση της μεταβλητής max_improvement, όπως στην παλία μας main, εντοπίζει την καλύτερη μέθοδο και εισάγει εκείνα τα steiner points που επιλέχθηκαν από αυτή.

- __Simulated Annealing__ : Ο αλγόριθμος αυτός υλοποιείται με ένα vector στο οποίο αποθηκέυονται τα steiner points για εισαγωγή στο τελικό cdt, ώστε να επιτευχθεί η νέα τριγωνοποίηση. Με τη χρήση της μεταβλητής T για τη θερμοκρασία και Ε για την ενέργεια, που υπολογίζεται από τη βοηθητική συνάρτηση double energy(PSLG *graph, CDT *cdt, double alpha, double beta),
για κάθε αμβλυγώνιο τρίγωνο επιλέγει με τη χρήση της __rand()__ μια τυχαία μέθοδο. Χρησιμοποιείται η συνάρτηση του PSLG __return_cdt()__ για επιστροφή ενός αντίγραφου του cdt, και συγκρίνεται η παλιά ενέργεια με την καινούρια που υπολογίζεται. Με τον υπολογισμό μιας πιθανότητας, επιλέγεται ή όχι η νέα τριγωνοποίηση με αυτή τη μέθοδο που επιλέχτηκε. Τελικά, εισάγονται τα steiner points στο cdt από το vector, αν έγινε αποδοχή, και η θερμοκρασία μειώνεται. Όταν λάβει αρνητικές τιμές, ο αλγόριθμος τερματίζει.

- __Ant Colony__ : Αποτελεί τον πιο περίπλοκο αλγόριθμο. Χρησιμοποιούνται διάφορες βοηθητικές συναρτήσεις, όπως η __ant_evaluate(double r)__ για τον υπολογισμό της ευρετικής αξιολόγησης για κάθε μυρμήγκι / πράκτορα, η __compute_r(CDT::Finite_faces_iterator it)__ για τον υπολογισμό του "radius to height ratio", με γεωμετρικούς τύπους όπως στις διαφάνειες (για να χρησιμοποιηθεί από τα μυρμήγκια) και η __update_pheromones(PSLG *graph, CDT *cdt, std::vector<double>& pheromones, double evaporation_rate, int num_obtuse, int num_steiner, double alpha, double beta, std::vector<std::vector<Point>>solutions)__. Στην τελευταία, δίνονται ως ορίσματα οι παράμετροι που χρειάζονται από τον χρήστη για τον υπολογισμό των νέων pheromones, και επίσης για την εύρεση των τιμών Δ_τsp, που στον κώδικα δίνονται από το vector differences για κάθε μέθοδο. 
Στη συνάρτηση αυτή ελέγχεται αν υπάρχει βελτίωση με flag __was_improved__, ελέγχοντας όλες τις λύσεις των μυρμηγκιών που είναι προσβάσιμες από το vector από vectors, solutions ως όρισμα. Η λογική είναι αυτή των διαφανειών του μαθήματος, με τον ψευδοκώδικα του αλγορίθμου. Για τα νέα pheromones, χρησιμοποιούνται τα υπολογισμένα differences και το λ (evaporation_rate), που δίνεται επίσης ως όρισμα.

Η συνάρτηση update_pheromones χρησιμοποιείται στο τέλος της βασικής συνάρτησης του αλγορίθμου, __ant_colony(PSLG *graph, CDT *cdt, double alpha, double beta, double x, double y, int K, int L, double lambda)__. Σε αυτή, υπολογίζονται οι αρχικές τιμές των steiner points και των αμβλυγώνιων τριγώνων στο σχήμα. Με τη χρήση της numeric_limits αρχικοποιούμε τις τιμές για τα μεγαλύτερα πλήθη από τα παραπάνω, ώστε να συγκρίνουμε στο τέλος και να αποθηκεύεται η καλύτερη τριγωνοποίηση τη δεδομένη στιγμή. Όπως και στο simulated annealing, χρησιμοποιείται ένα steiner point vector για να γίνει στο τέλος η εισαγωγή. Για κάθε κύκλο, ελέγχεται κάθε μέθοδος από κάθε μυρμήγκι. Σύμφωνα με τον αλγόριθμο, χρησιμοποιούνται η ευρετική συνάρτηση στο vector heuristics, και οι πιθανότητα για αποδοχή στο vector probabilities, για κάθε μέθοδο. Η μέθοδος τελικά επιλέγεται με κανονικοποίηση του vector των πιθανοτήτων, που βρίσκεται με τη βοήθεια της std::accumulate για την άθροιση, και τη χρήση κατανομής από τις πιθανότητες.
Αφού επιλεχτεί η μέθοδος, αποθηκεύεται το επιλεγμένο steiner point. Αν είναι έγκυρο, εισάγεται στο συγκεκριμένο ant solution vector, και προστίθεται στην κατάλληλη θέση στο συνολικό solution vector (solutions). Τελικά, διατρέχονται όλες οι λύσεις για τον κάθε κύκλο και με την προαναφερόμενη σύγκριση επιλέγεται η καλύτερη και εισάγονται τα steiner points κάθε μυρμηγκιού στο cdt, πριν γίνει το update_pheromones για να προχωρήσει ο αλγόριθμος στον επόμενο κύκλο. 
Ο αλγόριθμος τερματίζει ανάλογα με τον αριθμό κύκλων που έχει καθορίσει ο χρήστης από τα instances / tests (ή που υπάρχουν ήδη).

## ΠΑΡΑΤΗΡΗΣΕΙΣ ΓΙΑ ΤΗΝ ΑΠΟΤΕΛΕΣΜΑΤΙΚΟΤΗΤΑ ΤΩΝ ΑΛΓΟΡΙΘΜΩΝ
Η μέθοδος simulated annealing είναι η λιγότερο αποτελεσματική, καθώς πολλές φορές επιλέγει χειρότερη τριγωνοποίηση ανάλογα με την πιθανότητα. Η μέθοδος ant colony, αν και η πιο αργή λόγω των πολλών επαναλήψεων και ελέγχων (ειδικά για μεγάλο αριθμό κύκλων), είναι πιο αποδοτική σχετικά με τη μείωση των αμβλυγώνιων τριγώνων. Η μέθοδος local search παράγει αρκετά καλά αποτελέσματα, κατά μέσο όρο, αλλά δεν είναι ιδιαίτερα σύνθετη καθώς συγκρίνει όλες τις μεθόδους και δεν εκτελεί κάποια τυχαία ή καθορισμένη από παράγοντες επιλογή.